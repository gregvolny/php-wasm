{"version":3,"file":"static/js/774.54b28235.chunk.js","mappings":"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","sources":["../node_modules/@electric-sql/pglite/src/fs/opfs-ahp.ts"],"sourcesContent":["import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Uint8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n"],"names":["R","H","v","F","M","y","b","m","x","P","D","S","n","C","O","k","w","f","I","W","j","T","L","B","constructor","e","initialPoolSize","t","maintainedPoolSize","o","debug","i","arguments","length","undefined","super","g","Map","lastCheckpoint","checkpointInterval","poolCounter","Set","this","init","r","call","syncToFs","maybeCheckpointState","maintainPool","flush","closeFs","s","values","close","pg","Module","FS","quit","state","pool","push","Promise","async","a","Date","now","toString","padStart","h","getFileHandle","create","d","createSyncAccessHandle","set","opp","args","c","pop","get","removeEntry","name","delete","all","_createPoolFileState","_deletePoolFileState","indexOf","splice","checkpointState","TextEncoder","encode","JSON","stringify","truncate","write","at","clear","chmod","_chmodState","mode","fstat","lstat","type","backingFilename","getSize","dev","ino","nlink","uid","gid","rdev","size","blksize","blocks","Math","ceil","atime","lastModified","mtime","ctime","mkdir","_mkdirState","root","Object","prototype","hasOwnProperty","children","recursive","p","join","open","readdir","keys","read","Uint8Array","buffer","rename","_renameState","l","u","rmdir","_rmdirState","add","unlink","_unlinkState","has","utimes","_utimesState","writeFile","Error","startsWith","_createFileNodeState","_setLastModifiedState","WeakMap","WeakSet","E","navigator","storage","getDirectory","dataDir","from","ArrayBuffer","TextDecoder","decode","split","parse","slice","filter","Boolean","map","bind","N","console","warn","error","U","_","getDirectoryHandle","A","code","z"],"sourceRoot":""}